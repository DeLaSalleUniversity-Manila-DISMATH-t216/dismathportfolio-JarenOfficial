# MY DISMATH PORTFOLIO - JAN REINELL AGOY

dismathportfolio-JarenOfficial created by Classroom for GitHub

## WEEK 1:

- We introduced each other by telling our names, course, and favorite hobbies. 
- At first, I don't have any idea what Discrete Mathematics is about. 
- However, our professor discussed a brief introduction about it and it made me interested because it will enhance my critical thinking.
- I have learned that there are different classifications of truth: authoritative, legal, scientific, probable, philosophical, and mathematical. 
- I have learned that the primary focus of Discrete Mathematics is "mathematical" truth.
- I learned the definition of logic which is the <i>basis of all mathematical reasoning, and of all automated reasoning</i> (Rosen, 2007).
- I learned about propositions, a declarative statement that is either true or false but not both, and its definitions - negation, conjunction, disjunction, exclusive or, conditional, and biconditional. 
- I learned to use the truth table to prove logical statements. 
- I am introduced to new symbols for logic; ¬ (negation), ∧ (conjunction or "AND"), ∨ (disjunction or "OR"), ⊕ (exclusive or),  → (conditional or implication), and ↔ (biconditional). 
- In addition, we were introduced to the concepts of converse, inverse, and contrapositive. 
- Converse (p → q ≠ q → p), Inverse (¬p → ¬q), Contrapositive (¬q → ¬p).

## WEEK 2:

- I learned that using truth table has its limitations and there is another way to prove logical statements by the use of logical equivalences.
- There are different logical equivalences:

  | Equivalence | Name |
  | :---------: | :--: |
  | p ∧ <b>T</b> ≡ p <p>p ∨ <b>F</b> ≡ p</p> | Identity Laws |
  | p ∨ <b>T</b> ≡ <b>T</b> <p>p ∧ <b>F</b> ≡ <b>F</b> | Domination Laws |
  | p ∨ p ≡ p <p>p ∧ p ≡ p | Idempotent Laws |
  | ¬(¬p) ≡ p | Double Negation Law |
  | p ∨ q ≡ q ∨ p <p>p ∧ q ≡ q ∧ p</p> | Commutative Laws |
  | (p ∨ q) ∨ r ≡ q ∨ (p ∨ r) <p>(p ∧ q) ∧ r ≡ q ∧ (p ∧ r)</p> | Associative Laws |
  | p ∨ (q ∧ r) ≡ (p ∨ q) ∧ (q ∨ r) <p> p ∧ (q ∨ r) ≡ (p ∧ q) ∨ (q ∧ r)</p> | Distributive Laws |
  | ¬(p ∧ q) ≡ ¬p ∨ ¬q <p>¬(p ∨ q) ≡ ¬p ∧ ¬q</p> | De Morgan's Law |
  | p ∨ (p ∧ q) ≡ p <p>p ∧ (p ∨ q) ≡ p</p> | Absorption Laws |
  | p ∨ ¬p ≡ <b>T</b> <p>p ∧ ¬p ≡ <b>F</b> | Negation Laws |

- After logical equivalances, we learned about Predicate Logic and Quantifiers.
- Predicate Logic deals with propositions that contains predicates, which refers to the <i>property of the subject or statement can have</i> (Rosen, 2007). 
- I learned that quantification is a process of producing a proposition from a propositional function. 
- We are introducted to two quantifiers: " <i><b>For all</i></b> " (∀) Universal Quantification & " <i><b>There exists</i></b> " (∃) Existential Quantification.
- It is funny how our professor correlate the concept of quantification to how politicians say their platforms in elections because it made me critical to hear what platforms would electoral candidates establish and sell to the people this coming elections. 
- We are given a homework to prove if Superman really exists by using the rule of inference.
- I learned that the rule of inference states that an argument is <b>valid</b> if it follows the pattern of the rules of inference.
- I also learned that <i>validity</i> and <i>truth</i> are two different things because an argument can be valid but not true. 
- The rules of inference are <b> Modus Ponens, Modus Tollens, Hypothetical Syllogism, Disjunctive Syllogism, Addition, Simplification, Conjunction, and Resolution </b>.

## WEEK 3

- The Methods of Prood are introduced to us and as follows: <b>Direct Proof</b>, <b>Proof by Contraposition</b>, <b>Vacuuos Proof</b>, <b>Trivial Proof</b>, <b>Proof by Contradiction</b>, <b>Proof by Equivalence</b>, and <b>Mathematical Induction</b>.
- Direct Proof: <p>- Assume the p is true </p><p>-Then show that q is true</p>
- Proof by Contraposition: <p>- Assume the ¬q is true </p><p>-Then show that ¬p is true</p>
- Vacuuos Proof: <p>- Show that p is false </p><p>-Then p → q is true</p>
- Trivial Proof:  <p>- Show that q is true </p><p>-Then p → q is true</p>
- Proof of contradiction is slightly introduced.

## WEEK 4

- Proof of Contradiction: <p>- Show that ¬P is true (P is the whole statement) </p><p>-Then show that it will end up in a contradiction</p>
- Proof by equivalence: <p>- Show that p ↔ q  is true </p><p>-Then show that q ↔ p  is also true </p>
- Mathematical Induction: <p>- Use the basis step: substitute any element to P(k) </p><p>-Then use the inductive step: this is like direct proof in which you prove that P(k) is true and P(k+1) is true </p>
- Recursive and Summation

## WEEK 5

- Set Theories
- Set Builder Notation
- Set Membership
- Subsets & Power Sets
- Power Series
- Zeno's Paradox
- Cardinality

##WEEK 6

- We discussed about Functions.
- Functions can also be called as <i>mappings</i> or <i>transformations</i>.
- A function from a to b is a correspondence of one variable of b to each variable of b.
- We can say that if <i>f</i> is the function from A to B, then A is the <b>domain</b> of <i>f</i> and B is the <b>codomain</b> of <i>f</i>.
- Also, if <i>f(a) = b</i>, then b is the <b>image</b> of a and a is the <b>pre-image</b> of b.
- The <b>range</b> of a function is the set of all the images in the elements of A.
- There are different types of functions or correspondences: <b>One-to-one Function</b>, <b>Onto Function</b>, and <b>One-to-one Correspondence</b>.
- One-to-one Functions, also called as <b>injection or injective</b>, states that a function is considered to be in this case if and only if <i>f(a) = f(b)</i> implies that a = b for all a and b in the domain of <i>f</i>.
- Onto Functions, also called as <b>surjection</b> or <b>surjective</b>, states that a function is considered to be in this case if and only if for every element b ∈ B there is an element a ∈ A with <i>f(a) = b</i>.
- One-to-One Correspondence, also called as <b>bijection</b> or <b>bijective</b>, is both one-to-one and onto.

##WEEK 7

- No classes


##WEEK 8

- We are introduced to the concepts of Algorithms.
- An <b>algorithm</b> is a finite set of precise instructions for performing a computation or for solving a problem.
- There are different kinds of algorithms or pseudocodes specially designed for different kinds of problems. 
- One example is the <i>finding the maximum algorithm</i> - which aims to find the maximum element in a finite sequence. 
- Pseudocode: 
  <p> <b>procedure</b>(a<sub>1</sub>, a<sub>2</sub>,..., a<sub>n</sub>: integers)<br>
      max := a<sub>1</sub> <br>
      <b>for</b> i := 2 to n <br>
         <b>if</b> max < a<sub>i</sub> <b>then</b> max:= a<sub>i</sub> <br>
     (max is the largest element)</p>
- We are also taught about searching algorithms which aim to searchh for a particular element in a pool of elements. 
- It has two types - </i>Linear Search</i> & <i>Binary Search</i>.
- Pseudocodes:
  <p> <i>For Linear Search</i> <br>
      <b>procedure</b> <i>linear search</i>(x: integers, a<sub>1</sub>, a<sub>2</sub>,...,a<sub>n</sub>: distinct integers)<br>
      i := 1 <br>
      <b>while</b> (i ≤ n and x ≠ a<sub>i</sub>)<br>
         i := i + 1 <br>
      <b>if</b> i ≤ n <b> then </b> location := i <br>
      <b>else</b> location := -1 or 0 <br>
      {location is the subscriptt of the term that equals x, or is 0 or -1 if x is not found} </p>
  <p> </i>For Binary Search</i> <br>
      <b>procedure</b> <i>binary search</i>(x: integer, a<sub>1</sub>, a<sub>2</sub>,..., a<sub>n</sub>: increasing integers)<br>
      i := 1 {i is the left endpoint of search interval} <br>
      j := n {j is the right endpoint of search interval} <br>
      <b>while</b> i < j <br>
      <b>begin</b> <br>
          m := ⌊(i+j)/2⌋<br>
          <b>if</b> x > a<sub>m</sub> <b>then</b> i := m + 1 <br>
          <b>else</b> j := m <br>
      <b>end</b> <br>
      <b>if</b> x := a<sub>i</sub> <b>then</b> location := i <br>
      <b>else</b> location:= -1 or 0 <br>
      {location is the subscript of the term equal to x, or 0 or -1 if x is not found}</p>

##WEEK 9

- Other types of algorithms are discussed.
- One type of algorithm is the sorting algorithms which aims to sort elements in a set or sequence. 
- There are two types of sorting algorithms - <b>bubble sort</b> and <b>insertion sort</b>.
- Pseudocodes:
      <p><i>For Bubble Sort</i> <br>
      <b>procedure</b> <i>bubblesort</i>(a<sub>1</sub>, a<sub>2</sub>,..., a<sub>n</sub>: real numbers with n ≥ 2)<br>
      <b>for</b> i := 1 to n-1 <br>
         <b>for</b> j := 1 to n-i <br>
            <b>if</b> a<sub>j</sub> > a<sub>j+1</sub> <b>then</b> interchange a<sub>j</sub> and a<sub>j+1</sub><br>
      {a<sub>1</sub>,...,a<sub>n</sub> is in increasing order}</p>
      <p><i>For Insertion Sort</i><br>
      <b>procedure</b> <i>insertion sort</i>(a<sub>1</sub, a<sub>2</sub>,..., a<sub>n</sub>: real numbers with n ≥ 2)<br>
      <b>for</b> j := 2 to n <br>
      <b>begin</b><br>
         i := 1 <br>
         <b>while</b> a<sub>j</sub> > a<sub>i</sub><br>
              i := i + 1 <br>
         m := a<sub>j</sub><br>
         <b>for</b> k := 0 <b>to</b> j - i - 1 <br>
             a<sub>j-k</sub> := a<sub>j-k-1</sub><br>
         a<sub>i</sub> := m <br>
      <b>end</b> {a<sub>1</sub>, a<sub>2</sub>,..., a<sub>n</sub> are sorted}</p>
- Another type of algorithm discussed is the <b>Greedy Change Algorithm</b> that aims to choose what is "best".
- Pseudocode:
     <p><b>procedure</b> <i>change</i>(c<sub>1</sub>, c<sub>2</sub>,..., c<sub>r</sub>: values of denomination of coins where c<sub>1</sub> > c<sub>2</sub> > ... > c<sub>r</sub>; n: a positive integer)<br>
     <b>for</b> i := 1 <b>to</b> r <br>
         <b>while</b> n ≥ c<sub>i</sub> <br>
         <b>begin</b><br>
         add a coin with value c<sub>i</sub> to the change<br>
         n := n - c<sub>i</sub> <br>
         <b>end</b></p>

#WEEK 10

- We continued the discussion on Functions but focusing on the <i>Growth of Functions</i>.
- The growth of functions is often descrbed by a special notation.
- The notation is called the <b>Big-O Notation</b>.
- It states that let <i>f</i> and <i>g</i> be functions from the set of integers or the set of real numbers to the set of real numbers, we can say that <i>f(x)</i> is <i>O(g(x))</i> if there are constants <i>C</i> and <i>k</i> such that |<i>f(x)</i>| ≤ <i>C|g(x)|</i> whenever x > k. 
- Big-O notation is also called as the upper bound of the function. 
- There are other notations that are useful in determining the growth of functions - <b>Big-Omega & Big-Theta Notation</b>.
- Big-Omega Notation, also called as the lower bound of the function, states that if <i>f</i> and <i>g</i> be functions from the set of integers or the set of real numbers to the set of real numbers; we can say that <i>f(x)</i> is <i>Ω(g(x))</i> if there are positive constants <i>C</i> and <i>k</i> such that |<i>f(x)</i)| ≥ <i>C|g(x)|</i> whenever x > k. 
- Big-Theta Notation, the combination of the two former notations, states that <i>f</i> and <i>g</i> be functions from the set of real numbers or set of integers to the set of real numbers; we can say that <i>f(x)</i> is <i>Θ(g(x))</i> if <i>f(x)</i> is <i>O(g(x))</i> and <i>f(x)</i> is <i>Ω(g(x))</i>.
- One important concept in functions is the <b>time complexity</b> which is the amount of time required for an algorithm to solve a problem. 
- There are different kinds of complexities:

  | Complexity | Terminology |
  | :--------: | :---------: |
  | Θ(1) | Constant Complexity |
  | Θ(log n) | Logarithmic Complexity |
  | Θ(n) | Linear Complexity |
  | Θ(n log n) | n log n Complexity |
  | Θ(n<sup>b</sup>) | Polynomial Complexity |
  | Θ(b<sup>n</sup>, where b > 1 | Exponential Complexity |
  | Θ(n!) | Factorial Complexity |
  
- Division & Modulo is also discussed.
- Division when operated will give you the quotient while modulo will give you the remainder.

##WEEK 11

- No classes.

#WEEK 12

- Project Making discussion
- We discussed about Graph Theory that tests our visual ability.
- <b>Graphs</b> are discrete structures consisting of vertices and edges that connect these vertices. 
- I learned that graph with an infinite vertex set is called an <i>infinite graph</i>, and in comparison, a graph with a finite vertex set is called a <i>finite graph</i>.
- I also learned that a graph in which edge connects two different vertices and where no two edges connect the same pair of vertices is called a <b>simple graph</b>.
- I also learned about the degree of vertex is the number of edges connected in a vertex.
- By the Handshaking theorem, the summation of the degrees of the vertex is equals to twice of edges.
- Also i learned about the isolated and pendant.
- I also learned about Euler's circuit & Euler's path.
- A graph is considered to have an euler's path if it covers all the edges once, no repetitions. 
- A graph is considered to have an euler's circuit if it can go back to its starting point. 
- Another type is the Hamilton path and circuit. 
- In the case of hamilton path, a graph should be considered to have this if all the vertex or nodes are covered once.
- In Hamilton circuit, if there is a way that will make it return to its starting point then it has a hamilton circuit. 
- Also, there is what we call Euler's formula which can give you the number of regions. It is the difference of edges and vertices plus two. 
- A way to know the matrix of graphs is to use the adjacency matrix to see the connections. 
- Also, we learned to distinguish if a graph is planar or not planar.
- A graph is said to be not planar if it has a subgraph of K<sub>3,3</sub> or K<sub>5</sub> according to the Kuratowski's theorem.
- A graph is planar if it can be drawn without intersecting its edges. 

##WEEK 13

- We learned about Graph Coloring.
- If the graph is planar, the maximum chromatic number is 4.
- we also learned about trees which is similar to a flowchart.
- Trees are used to present data in an organized manner which are used in tracking history of a clan or family.
- I learned that trees are undirected graphs which does not acquire any circuits.
- I learned that the root is the main core of the tree then under it are the leaves. 
- We also learned about the n-ary trees and its formulas.
- We also discussed about the finite-state machines with output.
